// import { useState, useCallback, useEffect } from 'react';
// import { contentService } from '../services/content.service';
// import { ContentType, type ContentItem, type CreateContentData, type UpdateContentData } from '../types/content.types';
// import type { SectorType } from '../types/common.types';
// // ‚úÖ IMPORTAR FUN√á√ïES DE LOG SEGURO DO ENVUTILS
// import { 
//   safeLog, 
//   safeWarn, 
//   safeError, 
//   safeDebug, 
//   safeTime, 
//   safeTimeEnd, 
//   performanceLog,
//   ENV_CONFIG 
// } from '../utils/envUtils';

// interface UseContentOptions {
//   sector?: SectorType;
//   autoLoad?: boolean;
// }

// interface UseContentReturn {
//   // Estado
//   contents: ContentItem[];
//   loading: boolean;
//   error: string | null;
  
//   // A√ß√µes b√°sicas
//   loadContents: () => Promise<void>;
//   refreshContents: () => Promise<void>;
  
//   // CRUD de conte√∫do
//   createContent: (data: CreateContentData) => Promise<ContentItem>;
//   updateContent: (id: string, data: UpdateContentData) => Promise<ContentItem>;
//   deleteContent: (id: string) => Promise<boolean>;
  
//   // Wiki Additions
//   createWikiAddition: (data: {
//     contentId: string;
//     title: string;
//     textContent: string;
//     type: ContentType;
//     file?: File;
//     author?: string;
//   }) => Promise<boolean>;
//   deleteWikiAddition: (id: string | number) => Promise<boolean>;
  
//   // Upload de arquivos
//   uploadFile: (file: File) => Promise<any>;
//   deleteFile: (fileId: string) => Promise<boolean>;
  
//   // Utilit√°rios
//   getContentById: (id: string | number) => ContentItem | undefined;
//   clearError: () => void;
// }

// export const useContent = (options: UseContentOptions = {}): UseContentReturn => {
//   const { sector, autoLoad = true } = options;
  
//   // Estado
//   const [contents, setContents] = useState<ContentItem[]>([]);
//   const [loading, setLoading] = useState(false);
//   const [error, setError] = useState<string | null>(null);

//   // ‚úÖ UTILIT√ÅRIO PARA NOTIFICA√á√ïES
//   const showNotification = useCallback((message: string, type: 'success' | 'error' = 'success') => {
//     const notification = document.createElement('div');
//     const bgColor = type === 'success' ? 'bg-green-500' : 'bg-red-500';
//     notification.className = `fixed top-4 right-4 ${bgColor} text-white px-4 py-2 rounded shadow-lg z-50 max-w-sm`;
//     notification.textContent = message;
//     document.body.appendChild(notification);
    
//     setTimeout(() => {
//       if (document.body.contains(notification)) {
//         document.body.removeChild(notification);
//       }
//     }, type === 'error' ? 5000 : 3000);
//   }, []);

//   // ‚úÖ CARREGAR CONTE√öDOS COM PERFORMANCE TRACKING
//   const loadContents = useCallback(async () => {
//     const startTime = performance.now();
//     safeTime('useContent-loadContents');
    
//     setLoading(true);
//     setError(null);
    
//     try {
//       safeLog('üîÑ useContent: Carregando conte√∫dos...', { 
//         sector, 
//         timestamp: new Date().toISOString(),
//         autoLoad 
//       });
      
//       const data = sector ? 
//         await contentService.getContentsBySector(sector) : 
//         await contentService.getAllContents();
      
//       safeLog('‚úÖ useContent: Conte√∫dos carregados com sucesso:', {
//         count: data.length,
//         sector,
//         timestamp: new Date().toISOString(),
//         firstItem: data[0]?.title || 'Nenhum item',
//         hasWikiAdditions: data.some(item => (item as any)?.strapiData?.all_wiki_additions?.length > 0)
//       });
      
//       setContents(data);
//       performanceLog('Carregamento de conte√∫dos', startTime);
      
//     } catch (err: any) {
//       const errorMessage = err.message || 'Erro ao carregar conte√∫dos';
//       safeError('‚ùå useContent: Erro ao carregar conte√∫dos:', {
//         error: err.message || err,
//         stack: err.stack,
//         sector,
//         timestamp: new Date().toISOString()
//       });
//       setError(errorMessage);
//       showNotification(errorMessage, 'error');
//     } finally {
//       setLoading(false);
//       safeTimeEnd('useContent-loadContents');
//     }
//   }, [sector, showNotification, autoLoad]);

//   // ‚úÖ REFRESH COM LOG ESPEC√çFICO
//   const refreshContents = useCallback(() => {
//     safeLog('üîÑ useContent: Refresh manual solicitado');
//     return loadContents();
//   }, [loadContents]);

//   // ‚úÖ CRIAR CONTE√öDO COM LOGS DETALHADOS
//   const createContent = useCallback(async (data: CreateContentData): Promise<ContentItem> => {
//     const startTime = performance.now();
    
//     try {
//       safeLog('‚ûï useContent: Criando conte√∫do:', {
//         title: data.title,
//         type: data.type,
//         sector: data.sector,
//         hasFile: !!(data as any).file,
//         timestamp: new Date().toISOString()
//       });
      
//       const newContent = await contentService.createContent(data);
      
//       // ‚úÖ ATUALIZAR ESTADO LOCAL COM LOG
//       setContents(prev => {
//         const updated = [newContent, ...prev];
//         safeDebug('üìä useContent: Estado atualizado ap√≥s cria√ß√£o:', {
//           totalItens: updated.length,
//           novoItem: {
//             id: newContent.id,
//             title: newContent.title
//           }
//         });
//         return updated;
//       });
      
//       safeLog('‚úÖ useContent: Conte√∫do criado com sucesso:', {
//         id: newContent.id,
//         title: newContent.title,
//         timestamp: new Date().toISOString()
//       });
      
//       performanceLog('Cria√ß√£o de conte√∫do', startTime);
//       showNotification('Conte√∫do criado com sucesso!');
//       return newContent;
      
//     } catch (err: any) {
//       const errorMessage = err.message || 'Erro ao criar conte√∫do';
//       safeError('‚ùå useContent: Erro ao criar conte√∫do:', {
//         error: err.message || err,
//         data: { title: data.title, type: data.type },
//         timestamp: new Date().toISOString()
//       });
//       setError(errorMessage);
//       showNotification(errorMessage, 'error');
//       throw err;
//     }
//   }, [showNotification]);

//   // ‚úÖ ATUALIZAR CONTE√öDO COM COMPARA√á√ÉO SEGURA
//   const updateContent = useCallback(async (id: string, data: UpdateContentData): Promise<ContentItem> => {
//     const startTime = performance.now();
    
//     try {
//       safeLog('üîÑ useContent: Atualizando conte√∫do:', {
//         id,
//         updates: Object.keys(data),
//         timestamp: new Date().toISOString()
//       });
      
//       const updatedContent = await contentService.updateContent(id, data);
      
//       // ‚úÖ ATUALIZAR ESTADO LOCAL COM COMPARA√á√ÉO SEGURA E LOG
//       setContents(prev => {
//         const updated = prev.map(content => {
//           const match = content.id.toString() === id.toString();
//           if (match) {
//             safeDebug('üîÑ useContent: Item atualizado no estado:', {
//               id: content.id,
//               oldTitle: content.title,
//               newTitle: updatedContent.title
//             });
//           }
//           return match ? updatedContent : content;
//         });
        
//         safeDebug('üìä useContent: Estado ap√≥s atualiza√ß√£o:', {
//           totalItens: updated.length,
//           itemAtualizado: updatedContent.title
//         });
        
//         return updated;
//       });
      
//       safeLog('‚úÖ useContent: Conte√∫do atualizado com sucesso:', {
//         id,
//         title: updatedContent.title,
//         timestamp: new Date().toISOString()
//       });
      
//       performanceLog('Atualiza√ß√£o de conte√∫do', startTime);
//       showNotification('Conte√∫do atualizado com sucesso!');
//       return updatedContent;
      
//     } catch (err: any) {
//       const errorMessage = err.message || 'Erro ao atualizar conte√∫do';
//       safeError('‚ùå useContent: Erro ao atualizar conte√∫do:', {
//         error: err.message || err,
//         id,
//         updates: Object.keys(data),
//         timestamp: new Date().toISOString()
//       });
//       setError(errorMessage);
//       showNotification(errorMessage, 'error');
//       throw err;
//     }
//   }, [showNotification]);

//   // ‚úÖ EXCLUIR CONTE√öDO COM VERIFICA√á√ÉO E RELOAD
//   const deleteContent = useCallback(async (id: string): Promise<boolean> => {
//     const startTime = performance.now();
    
//     try {
//       safeLog('üóëÔ∏è useContent: Iniciando exclus√£o de conte√∫do:', {
//         id,
//         timestamp: new Date().toISOString()
//       });
      
//       // ‚úÖ BUSCAR ITEM ANTES DA EXCLUS√ÉO PARA LOG
//       const itemToDelete = contents.find(c => c.id.toString() === id.toString());
//       if (itemToDelete) {
//         safeDebug('üìã useContent: Item a ser exclu√≠do:', {
//           id: itemToDelete.id,
//           title: itemToDelete.title,
//           wikiAdditions: (itemToDelete as any)?.strapiData?.all_wiki_additions?.length || 0
//         });
//       }
      
//       const result = await contentService.deleteContent(id);
      
//       safeLog('üìã useContent: Resposta da exclus√£o:', {
//         result,
//         success: result.success,
//         message: result.message,
//         timestamp: new Date().toISOString()
//       });
      
//       if (result.success) {
//         safeLog('‚úÖ useContent: Exclus√£o confirmada pela API');
        
//         // ‚úÖ AGUARDAR UM POUCO PARA GARANTIR PERSIST√äNCIA
//         safeDebug('‚è≥ useContent: Aguardando persist√™ncia no servidor...');
//         await new Promise(resolve => setTimeout(resolve, 1500));
        
//         // ‚úÖ FAZER RELOAD COMPLETO PARA GARANTIR SINCRONIZA√á√ÉO
//         safeLog('üîÑ useContent: Recarregando lista completa ap√≥s exclus√£o...');
//         await loadContents();
        
//         performanceLog('Exclus√£o de conte√∫do (com reload)', startTime);
//         showNotification('Conte√∫do exclu√≠do com sucesso!');
//         return true;
        
//       } else {
//         throw new Error(result.message || 'Falha ao excluir conte√∫do');
//       }
      
//     } catch (err: any) {
//       const errorMessage = err.message || 'Erro ao excluir conte√∫do';
//       safeError('‚ùå useContent: Erro na exclus√£o:', {
//         error: err.message || err,
//         id,
//         stack: err.stack,
//         timestamp: new Date().toISOString()
//       });
//       setError(errorMessage);
//       showNotification(errorMessage, 'error');
//       return false;
//     }
//   }, [contents, loadContents, showNotification]);

//   // ‚úÖ CRIAR WIKI ADDITION COM LOGS DETALHADOS
//   const createWikiAddition = useCallback(async (data: {
//     contentId: string;
//     title: string;
//     textContent: string;
//     type: ContentType;
//     file?: File;
//     author?: string;
//   }): Promise<boolean> => {
//     const startTime = performance.now();
    
//     try {
//       safeLog('‚ûï useContent: Iniciando cria√ß√£o de Wiki Addition:', {
//         contentId: data.contentId,
//         title: data.title,
//         type: data.type,
//         hasFile: !!data.file,
//         author: data.author || 'Sistema',
//         timestamp: new Date().toISOString()
//       });
      
//       // ‚úÖ BUSCAR O CONTENT PARA PEGAR DOCUMENT ID
//       const content = contents.find(c => c.id.toString() === data.contentId);
      
//       if (!content) {
//         throw new Error(`Content com ID ${data.contentId} n√£o encontrado no estado local`);
//       }
      
//       const documentId = (content as any)?.strapiData?.documentId;
//       if (!documentId) {
//         throw new Error(`DocumentId n√£o encontrado para o content ID ${data.contentId}`);
//       }
      
//       safeLog('üìä useContent: Content parent localizado:', {
//         contentId: data.contentId,
//         documentId: documentId,
//         contentTitle: content?.title,
//         existingAdditions: (content as any)?.strapiData?.all_wiki_additions?.length || 0,
//         timestamp: new Date().toISOString()
//       });
      
//       // ‚úÖ USAR CONTENTSERVICE COM DOCUMENT ID
//       const result = await contentService.createWikiAddition({
//         contentId: documentId, // ‚úÖ PASSAR DOCUMENT ID
//         title: data.title,
//         textContent: data.textContent,
//         type: data.type,
//         file: data.file,
//         author: data.author
//       });

//       if (result.success) {
//         safeLog('‚úÖ useContent: Wiki addition criada com sucesso:', {
//           resultData: result.data,
//           timestamp: new Date().toISOString()
//         });
        
//         // ‚úÖ AGUARDAR UM POUCO E RECARREGAR PARA PEGAR A NOVA ADI√á√ÉO
//         safeDebug('‚è≥ useContent: Aguardando antes do reload...');
//         await new Promise(resolve => setTimeout(resolve, 2000));
        
//         safeLog('üîÑ useContent: Recarregando conte√∫dos para incluir nova adi√ß√£o...');
//         await loadContents();
        
//         performanceLog('Cria√ß√£o de Wiki Addition (com reload)', startTime);
//         showNotification(`Nova adi√ß√£o "${data.title}" criada com sucesso!`, 'success');
//         return true;
        
//       } else {
//         throw new Error(result.message || 'Falha ao criar Wiki Addition');
//       }
      
//     } catch (err: any) {
//       const errorMessage = err.message || 'Erro ao criar adi√ß√£o';
//       safeError('‚ùå useContent: Erro ao criar Wiki Addition:', {
//         error: err.message || err,
//         data: {
//           contentId: data.contentId,
//           title: data.title,
//           type: data.type
//         },
//         stack: err.stack,
//         timestamp: new Date().toISOString()
//       });
//       setError(errorMessage);
//       showNotification(errorMessage, 'error');
//       return false;
//     }
//   }, [contents, loadContents, showNotification]);

//   // ‚úÖ EXCLUIR WIKI ADDITION COM VERIFICA√á√ïES
//   const deleteWikiAddition = useCallback(async (id: string | number): Promise<boolean> => {
//     const startTime = performance.now();
    
//     try {
//       safeLog('üóëÔ∏è useContent: Iniciando exclus√£o de Wiki Addition:', {
//         id,
//         idType: typeof id,
//         timestamp: new Date().toISOString()
//       });
      
//       if (!id) {
//         throw new Error('ID da adi√ß√£o n√£o fornecido');
//       }
      
//       // ‚úÖ BUSCAR A ADI√á√ÉO NOS DADOS ATUAIS PARA LOG
//       const parentContent = contents.find(content => {
//         const additions = (content as any)?.strapiData?.all_wiki_additions || [];
//         return additions.some((addition: any) => addition.id === Number(id) || addition.id === String(id));
//       });
      
//       if (parentContent) {
//         safeDebug('üìã useContent: Wiki Addition encontrada para exclus√£o:', {
//           parentContentId: parentContent.id,
//           parentContentTitle: parentContent.title,
//           additionId: id
//         });
//       }
      
//       const result = await contentService.deleteWikiAddition(id);

//       safeLog('üìã useContent: Resposta da exclus√£o de Wiki Addition:', {
//         result,
//         success: result.success,
//         message: result.message,
//         timestamp: new Date().toISOString()
//       });

//       if (result.success) {
//         safeLog('‚úÖ useContent: Wiki Addition exclu√≠da com sucesso via API');
        
//         // ‚úÖ AGUARDAR E RECARREGAR
//         safeDebug('‚è≥ useContent: Aguardando persist√™ncia...');
//         await new Promise(resolve => setTimeout(resolve, 1500));
        
//         safeLog('üîÑ useContent: Recarregando para atualizar wiki additions...');
//         await loadContents();
        
//         performanceLog('Exclus√£o de Wiki Addition (com reload)', startTime);
//         showNotification('Adi√ß√£o exclu√≠da com sucesso!', 'success');
//         return true;
        
//       } else {
//         throw new Error(result.message || 'Falha ao excluir adi√ß√£o');
//       }
      
//     } catch (err: any) {
//       const errorMessage = err.message || 'Erro ao excluir adi√ß√£o';
//       safeError('‚ùå useContent: Erro ao excluir Wiki Addition:', {
//         error: err.message || err,
//         id,
//         idType: typeof id,
//         stack: err.stack,
//         timestamp: new Date().toISOString()
//       });
//       setError(errorMessage);
//       showNotification(errorMessage, 'error');
//       return false;
//     }
//   }, [contents, loadContents, showNotification]);

//   // ‚úÖ NOVO: ATUALIZAR WIKI ADDITION COM LOGS DETALHADOS
//   const updateWikiAddition = useCallback(async (data: {
//     additionId: string | number;
//     contentId: string; // ID do artigo principal
//     title: string;
//     textContent: string;
//     type: ContentType;
//     file?: File;
//     author?: string;
//   }): Promise<boolean> => {
//     const startTime = performance.now();
//     
//     try {
//       safeLog('üîÑ useContent: Iniciando atualiza√ß√£o de Wiki Addition:', { 
//         additionId: data.additionId, 
//         contentId: data.contentId, 
//         title: data.title, 
//         type: data.type, 
//         hasFile: !!data.file,
//         timestamp: new Date().toISOString()
//       });
//     
//     // Valida√ß√£o de entrada
//     if (!data.additionId) {
//       throw new Error('ID da adi√ß√£o n√£o fornecido');
//     }
//     
//     // Preparar dados para atualiza√ß√£o
//     const additionId = Number(data.additionId);
//     if (isNaN(additionId)) {
//       throw new Error(`ID da adi√ß√£o inv√°lido: ${data.additionId}`);
//     }
//     
//     // Criar conte√∫do formatado para o Strapi
//     const content = [
//       {
//         type: 'paragraph',
//         children: [{ text: data.textContent || '', type: 'text' }]
//       }
//     ];
//     
//     // Preparar dados para atualiza√ß√£o
//     const updateData: Partial<any> = {
//       title: data.title,
//       content: content,
//       author: data.author || 'Sistema'
//     };
//     
//     // Se houver arquivo, fazer upload primeiro
//     if (data.file) {
//       try {
//         const uploadResult = await contentService.uploadFile(data.file);
//         if (uploadResult && uploadResult.length > 0) {
//           updateData.attachments = {
//             connect: [uploadResult[0].id]
//           };
//         }
//       } catch (uploadError) {
//         safeWarn('‚ö†Ô∏è useContent: Falha no upload, continuando sem arquivo:', uploadError);
//       }
//     }
//     
//     // Chamar o servi√ßo de atualiza√ß√£o
//     const result = await contentService.updateWikiAddition(additionId, updateData);
//     
//     safeLog('‚úÖ useContent: Wiki addition atualizada com sucesso:', { 
//       additionId: data.additionId, 
//       result: result,
//       timestamp: new Date().toISOString()
//     });
//     
//     // Recarregar conte√∫dos para refletir as mudan√ßas
//     await loadContents();
//     
//     performanceLog('Atualiza√ß√£o de Wiki Addition', startTime);
//     showNotification(`Adi√ß√£o "${data.title}" atualizada com sucesso!`, 'success');
//     return true;
//   } catch (err: any) {
//     const errorMessage = err.message || 'Erro ao atualizar adi√ß√£o';
//     safeError('‚ùå useContent: Erro ao atualizar Wiki Addition:', {
//       error: err.message || err,
//       data: {
//         additionId: data.additionId,
//         contentId: data.contentId,
//         title: data.title
//       },
//       stack: err.stack,
//       timestamp: new Date().toISOString()
//     });
//     setError(errorMessage);
//     showNotification(errorMessage, 'error');
//     return false;
//   }
// }, [loadContents, showNotification]);

  const uploadFile = useCallback(async (file: File) => {
    const startTime = performance.now();
    
    try {
      safeLog('üì§ useContent: Iniciando upload de arquivo:', {
        fileName: file.name,
        fileSize: `${(file.size / 1024).toFixed(2)} KB`,
        fileType: file.type,
        timestamp: new Date().toISOString()
      });
      
      // ‚úÖ VALIDA√á√ïES COM LOGS
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (file.size > maxSize) {
        const errorMsg = `Arquivo muito grande: ${(file.size / 1024 / 1024).toFixed(2)}MB. M√°ximo: 10MB`;
        safeWarn('‚ö†Ô∏è useContent: Arquivo muito grande:', {
          fileName: file.name,
          fileSize: file.size,
          maxSize
        });
        throw new Error(errorMsg);
      }
      
      const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/webm'];
      if (!allowedTypes.includes(file.type)) {
        safeWarn('‚ö†Ô∏è useContent: Tipo de arquivo n√£o suportado:', {
          fileName: file.name,
          fileType: file.type,
          allowedTypes
        });
        throw new Error(`Tipo de arquivo n√£o suportado: ${file.type}. Use: ${allowedTypes.join(', ')}`);
      }
      
      const result = await contentService.uploadFile(file);
      
      safeLog('‚úÖ useContent: Upload realizado com sucesso:', {
        fileName: file.name,
        result: result[0] ? {
          id: result[0].id,
          name: result[0].name,
          url: result[0].url,
          size: result[0].size
        } : result,
        timestamp: new Date().toISOString()
      });
      
      performanceLog('Upload de arquivo', startTime);
      showNotification('Arquivo enviado com sucesso!');
      return result;
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro no upload';
      safeError('‚ùå useContent: Erro no upload:', {
        error: err.message || err,
        fileName: file.name,
        fileSize: file.size,
        stack: err.stack,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      throw err;
    }
  }, [showNotification]);

  const deleteFile = useCallback(async (fileId: string): Promise<boolean> => {
    try {
      safeLog('üóëÔ∏è useContent: Iniciando exclus√£o de arquivo:', {
        fileId,
        timestamp: new Date().toISOString()
      });
      
      if (!fileId) {
        throw new Error('ID do arquivo inv√°lido');
      }
      
      const result = await contentService.deleteFile(fileId);

      if (result.success) {
        safeLog('‚úÖ useContent: Arquivo exclu√≠do com sucesso:', {
          fileId,
          timestamp: new Date().toISOString()
        });
        showNotification('Arquivo exclu√≠do com sucesso!', 'success');
        return true;
      } else {
        throw new Error(result.message || 'Falha ao excluir arquivo');
      }
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao excluir arquivo';
      safeError('‚ùå useContent: Erro ao excluir arquivo:', {
        error: err.message || err,
        fileId,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      return false;
    }
  }, [showNotification]);

  const getContentById = useCallback((id: string | number): ContentItem | undefined => {
    const content = contents.find(content => content.id.toString() === id.toString());
    
    if (ENV_CONFIG.isDev) {
      safeDebug('üîç useContent: Busca por ID:', {
        searchId: id,
        found: !!content,
        foundTitle: content?.title,
        totalContents: contents.length
      });
    }
    
    return content;
  }, [contents]);

  const clearError = useCallback(() => {
    safeLog('üßπ useContent: Limpando erro');
    setError(null);
  }, []);

  useEffect(() => {
    if (autoLoad) {
      safeLog('üöÄ useContent: Auto load habilitado:', {
        sector,
        timestamp: new Date().toISOString()
      });
      loadContents();
    } else {
      safeLog('‚è∏Ô∏è useContent: Auto load desabilitado');
    }
  }, [autoLoad, loadContents]);

  useEffect(() => {
    if (ENV_CONFIG.isDev) { 
      safeDebug('üìä useContent: Estado atualizado:', {
        contentsCount: contents.length,
        loading,
        hasError: !!error,
        errorMessage: error,
        sector,
        timestamp: new Date().toISOString(),
        contentsWithAdditions: contents.filter(c => (c as any)?.strapiData?.all_wiki_additions?.length > 0).length
      });
    }
  }, [contents.length, loading, error, sector]);

  return {
    // Estado
    contents,
    loading,
    error,
    
    // A√ß√µes b√°sicas
    loadContents,
    refreshContents,
    
    // CRUD de conte√∫do
    createContent,
    updateContent,
    deleteContent,
    
    // Wiki Additions
    createWikiAddition,
    deleteWikiAddition,
    
    // Upload de arquivos
    uploadFile,
    deleteFile,
    
    // Utilit√°rios
    getContentById,
    clearError,
  };
};

export default useContent;



/// arquivo em teste 


import { useState, useCallback, useEffect } from 'react';
import { contentService } from '../services/content.service';
import { ContentType, type ContentItem, type CreateContentData, type UpdateContentData } from '../types/content.types';
import type { SectorType } from '../types/common.types';
import { 
  safeLog, 
  safeWarn, 
  safeError, 
  safeDebug, 
  safeTime, 
  safeTimeEnd, 
  performanceLog,
  ENV_CONFIG 
} from '../utils/envUtils';

interface UseContentOptions {
  sector?: SectorType;
  autoLoad?: boolean;
}

interface UseContentReturn {
  // Estado
  contents: ContentItem[];
  loading: boolean;
  error: string | null;
  
  // A√ß√µes b√°sicas
  loadContents: () => Promise<void>;
  refreshContents: () => Promise<void>;
  
  // CRUD de conte√∫do
  createContent: (data: CreateContentData) => Promise<ContentItem>;
  updateContent: (id: string, data: UpdateContentData) => Promise<ContentItem>;
  deleteContent: (id: string) => Promise<boolean>;
  
  // Wiki Additions
  createWikiAddition: (data: {
    contentId: string;
    title: string;
    textContent: string;
    type: ContentType;
    file?: File;
    author?: string;
  }) => Promise<boolean>;
  deleteWikiAddition: (id: string | number) => Promise<boolean>;
  
  // Upload de arquivos
  uploadFile: (file: File) => Promise<any>;
  deleteFile: (fileId: string) => Promise<boolean>;
  
  // Utilit√°rios
  getContentById: (id: string | number) => ContentItem | undefined;
  clearError: () => void;
}

export const useContent = (options: UseContentOptions = {}): UseContentReturn => {
  const { sector, autoLoad = true } = options;
  
  // Estado
  const [contents, setContents] = useState<ContentItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const showNotification = useCallback((message: string, type: 'success' | 'error' = 'success') => {
    const notification = document.createElement('div');
    const bgColor = type === 'success' ? 'bg-green-500' : 'bg-red-500';
    notification.className = `fixed top-4 right-4 ${bgColor} text-white px-4 py-2 rounded shadow-lg z-50 max-w-sm`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
      if (document.body.contains(notification)) {
        document.body.removeChild(notification);
      }
    }, type === 'error' ? 5000 : 3000);
  }, []);

  const loadContents = useCallback(async () => {
    const startTime = performance.now();
    safeTime('useContent-loadContents');
    
    setLoading(true);
    setError(null);
    
    try {
      safeLog('üîÑ useContent: Carregando conte√∫dos...', { 
        sector, 
        timestamp: new Date().toISOString(),
        autoLoad 
      });
      
      const data = sector ? 
        await contentService.getContentsBySector(sector) : 
        await contentService.getAllContents();
      
      safeLog('‚úÖ useContent: Conte√∫dos carregados com sucesso:', {
        count: data.length,
        sector,
        timestamp: new Date().toISOString(),
        firstItem: data[0]?.title || 'Nenhum item',
        hasWikiAdditions: data.some(item => (item as any)?.strapiData?.all_wiki_additions?.length > 0)
      });
      
      setContents(data);
      performanceLog('Carregamento de conte√∫dos', startTime);
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao carregar conte√∫dos';
      safeError('‚ùå useContent: Erro ao carregar conte√∫dos:', {
        error: err.message || err,
        stack: err.stack,
        sector,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
    } finally {
      setLoading(false);
      safeTimeEnd('useContent-loadContents');
    }
  }, [sector, showNotification, autoLoad]);

  const refreshContents = useCallback(() => {
    safeLog('üîÑ useContent: Refresh manual solicitado');
    return loadContents();
  }, [loadContents]);

  const createContent = useCallback(async (data: CreateContentData): Promise<ContentItem> => {
    const startTime = performance.now();
    
    try {
      safeLog('‚ûï useContent: Criando conte√∫do:', {
        title: data.title,
        type: data.type,
        sector: data.sector,
        hasFile: !!(data as any).file,
        timestamp: new Date().toISOString()
      });
      
      const newContent = await contentService.createContent(data);
      
      setContents(prev => {
        const updated = [newContent, ...prev];
        safeDebug('üìä useContent: Estado atualizado ap√≥s cria√ß√£o:', {
          totalItens: updated.length,
          novoItem: {
            id: newContent.id,
            title: newContent.title
          }
        });
        return updated;
      });
      
      safeLog('‚úÖ useContent: Conte√∫do criado com sucesso:', {
        id: newContent.id,
        title: newContent.title,
        timestamp: new Date().toISOString()
      });
      
      performanceLog('Cria√ß√£o de conte√∫do', startTime);
      showNotification('Conte√∫do criado com sucesso!');
      return newContent;
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao criar conte√∫do';
      safeError('‚ùå useContent: Erro ao criar conte√∫do:', {
        error: err.message || err,
        data: { title: data.title, type: data.type },
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      throw err;
    }
  }, [showNotification]);

  const updateContent = useCallback(async (id: string, data: UpdateContentData): Promise<ContentItem> => {
    const startTime = performance.now();
    
    try {
      safeLog('üîÑ useContent: Atualizando conte√∫do:', {
        id,
        updates: Object.keys(data),
        timestamp: new Date().toISOString()
      });
      
      const updatedContent = await contentService.updateContent(id, data);
      
      setContents(prev => {
        const updated = prev.map(content => {
          const match = content.id.toString() === id.toString();
          if (match) {
            safeDebug('üîÑ useContent: Item atualizado no estado:', {
              id: content.id,
              oldTitle: content.title,
              newTitle: updatedContent.title
            });
          }
          return match ? updatedContent : content;
        });
        
        safeDebug('üìä useContent: Estado ap√≥s atualiza√ß√£o:', {
          totalItens: updated.length,
          itemAtualizado: updatedContent.title
        });
        
        return updated;
      });
      
      safeLog('‚úÖ useContent: Conte√∫do atualizado com sucesso:', {
        id,
        title: updatedContent.title,
        timestamp: new Date().toISOString()
      });
      
      performanceLog('Atualiza√ß√£o de conte√∫do', startTime);
      showNotification('Conte√∫do atualizado com sucesso!');
      return updatedContent;
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao atualizar conte√∫do';
      safeError('‚ùå useContent: Erro ao atualizar conte√∫do:', {
        error: err.message || err,
        id,
        updates: Object.keys(data),
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      throw err;
    }
  }, [showNotification]);

  const deleteContent = useCallback(async (id: string): Promise<boolean> => {
    const startTime = performance.now();
    
    try {
      safeLog('üóëÔ∏è useContent: Iniciando exclus√£o de conte√∫do:', {
        id,
        timestamp: new Date().toISOString()
      });
      
      const result = await contentService.deleteContent(id);
      
      if (result.success) {
        safeLog('‚úÖ useContent: Exclus√£o confirmada pela API');
        
        // ‚úÖ CORRE√á√ÉO: Remove o item localmente para feedback instant√¢neo.
        setContents(prev => {
            const updated = prev.filter(content => content.id.toString() !== id.toString());
            safeDebug('üìä useContent: Estado ap√≥s exclus√£o local:', { totalItens: updated.length });
            return updated;
        });

        // E ent√£o recarrega a lista do backend para garantir que o estado local
        // e o do servidor estejam sincronizados.
        await loadContents();
        
        performanceLog('Exclus√£o de conte√∫do', startTime);
        showNotification('Conte√∫do exclu√≠do com sucesso!', 'success');
        return true;
        
      } else {
        throw new Error(result.message || 'Falha ao excluir conte√∫do');
      }
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao excluir conte√∫do';
      safeError('‚ùå useContent: Erro na exclus√£o:', {
        error: err.message || err,
        id,
        stack: err.stack,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      return false;
    }
  }, [loadContents, showNotification]);

  const createWikiAddition = useCallback(async (data: {
    contentId: string;
    title: string;
    textContent: string;
    type: ContentType;
    file?: File;
    author?: string;
  }): Promise<boolean> => {
    const startTime = performance.now();
    
    try {
      safeLog('‚ûï useContent: Iniciando cria√ß√£o de Wiki Addition:', {
        contentId: data.contentId,
        title: data.title,
        type: data.type,
        hasFile: !!data.file,
        author: data.author || 'Sistema',
        timestamp: new Date().toISOString()
      });
      
      const content = contents.find(c => c.id.toString() === data.contentId);
      if (!content) {
        throw new Error(`Content com ID ${data.contentId} n√£o encontrado no estado local`);
      }
      
      const documentId = (content as any)?.strapiData?.documentId || content.id.toString();
      if (!documentId) {
        throw new Error(`DocumentId n√£o encontrado para o content ID ${data.contentId}`);
      }
      
      safeLog('üìä useContent: Content parent localizado:', {
        contentId: data.contentId,
        documentId: documentId,
        contentTitle: content?.title,
        existingAdditions: (content as any)?.strapiData?.all_wiki_additions?.length || 0,
        timestamp: new Date().toISOString()
      });
      
      const result = await contentService.createWikiAddition({
        contentId: documentId,
        title: data.title,
        textContent: data.textContent,
        type: data.type,
        file: data.file,
        author: data.author
      });

      if (result.success) {
        safeLog('‚úÖ useContent: Wiki addition criada com sucesso:', {
          resultData: result.data,
          timestamp: new Date().toISOString()
        });
        
        await loadContents();
        
        performanceLog('Cria√ß√£o de Wiki Addition (com reload)', startTime);
        showNotification(`Nova adi√ß√£o "${data.title}" criada com sucesso!`, 'success');
        return true;
        
      } else {
        throw new Error(result.message || 'Falha ao criar Wiki Addition');
      }
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao criar adi√ß√£o';
      safeError('‚ùå useContent: Erro ao criar Wiki Addition:', {
        error: err.message || err,
        data: {
          contentId: data.contentId,
          title: data.title,
          type: data.type
        },
        stack: err.stack,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      return false;
    }
  }, [contents, loadContents, showNotification]);

  const deleteWikiAddition = useCallback(async (id: string | number): Promise<boolean> => {
    const startTime = performance.now();
    
    try {
      safeLog('üóëÔ∏è useContent: Iniciando exclus√£o de Wiki Addition:', {
        id,
        idType: typeof id,
        timestamp: new Date().toISOString()
      });
      
      if (!id) {
        throw new Error('ID da adi√ß√£o n√£o fornecido');
      }

      // Converte para string para garantir compara√ß√£o consistente
      const idStr = String(id);
      safeLog('‚ÑπÔ∏è useContent: ID convertido para string para compara√ß√£o:', { idStr });

      // ‚úÖ CORRE√á√ÉO: Remove o item localmente para feedback instant√¢neo.
      setContents(prevContents => {
        const newContents = prevContents.map(item => {
          const strapiData = item.strapiData || {};
          const allWikiAdditions = strapiData.all_wiki_additions || [];
          
          // Filtra as adi√ß√µes que n√£o correspondem ao ID a ser exclu√≠do
          const updatedAdditions = allWikiAdditions.filter((add: any) => {
            if (!add || !add.id) return true; // Ignora itens inv√°lidos
            
            const addIdStr = String(add.id);
            const matches = addIdStr !== idStr;
            if (!matches) {
              safeLog('‚ÑπÔ∏è useContent: Encontrada adi√ß√£o para remover localmente:', { 
                contentId: item.id, 
                additionId: add.id,
                additionTitle: add.title
              });
            }
            return matches;
          });
          
          // Se o n√∫mero de adi√ß√µes mudou, registra a remo√ß√£o
          if (updatedAdditions.length !== allWikiAdditions.length) {
            safeLog('üìä useContent: Wiki addition removida localmente do estado.', { 
              contentId: item.id, 
              additionId: id,
              removedCount: allWikiAdditions.length - updatedAdditions.length
            });
          }
          
          return {
            ...item,
            strapiData: {
              ...strapiData,
              all_wiki_additions: updatedAdditions
            }
          };
        });
        
        return newContents;
      });
      
      safeLog('üîÑ useContent: Chamando API para excluir Wiki Addition:', { id });
      const result = await contentService.deleteWikiAddition(id);

      if (result.success) {
        safeLog('‚úÖ useContent: Wiki Addition exclu√≠da com sucesso via API:', {
          id,
          resultData: result.data
        });
        
        // Em caso de sucesso, recarrega para sincronizar.
        safeLog('üîÑ useContent: Recarregando conte√∫dos ap√≥s exclus√£o bem-sucedida');
        await loadContents();
        
        performanceLog('Exclus√£o de Wiki Addition', startTime);
        showNotification('Adi√ß√£o exclu√≠da com sucesso!', 'success');
        return true;
      } else {
        throw new Error(result.message || 'Falha ao excluir adi√ß√£o');
      }
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao excluir adi√ß√£o';
      safeError('‚ùå useContent: Erro ao excluir Wiki Addition:', {
        error: err.message || err,
        id,
        idType: typeof id,
        stack: err.stack,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      return false;
    }
  }, [loadContents, showNotification]);

  // ‚úÖ NOVO: ATUALIZAR WIKI ADDITION COM LOGS DETALHADOS
  const updateWikiAddition = useCallback(async (data: {
    additionId: string | number;
    contentId: string; // ID do artigo principal
    title: string;
    textContent: string;
    type: ContentType;
    file?: File;
    author?: string;
  }): Promise<boolean> => {
    const startTime = performance.now();
    
    try {
      safeLog('üîÑ useContent: Iniciando atualiza√ß√£o de Wiki Addition:', { 
        additionId: data.additionId, 
        contentId: data.contentId, 
        title: data.title, 
        type: data.type, 
        hasFile: !!data.file,
        timestamp: new Date().toISOString()
      });

      // Valida√ß√£o de entrada
      if (!data.additionId) {
        throw new Error('ID da adi√ß√£o n√£o fornecido');
      }

      // Preparar dados para atualiza√ß√£o
      const additionId = Number(data.additionId);
      if (isNaN(additionId)) {
        throw new Error(`ID da adi√ß√£o inv√°lido: ${data.additionId}`);
      }

      // Criar conte√∫do formatado para o Strapi
      const content = [
        {
          type: 'paragraph',
          children: [{ text: data.textContent || '', type: 'text' }]
        }
      ];

      // Preparar dados para atualiza√ß√£o
      const updateData: Partial<any> = {
        title: data.title,
        content: content,
        author: data.author || 'Sistema'
      };

      // Se houver arquivo, fazer upload primeiro
      if (data.file) {
        try {
          const uploadResult = await contentService.uploadFile(data.file);
          if (uploadResult && uploadResult.length > 0) {
            updateData.attachments = {
              connect: [uploadResult[0].id]
            };
          }
        } catch (uploadError) {
          safeWarn('‚ö†Ô∏è useContent: Falha no upload, continuando sem arquivo:', uploadError);
        }
      }

      // Chamar o servi√ßo de atualiza√ß√£o
      const result = await contentService.updateWikiAddition(additionId, updateData);

      safeLog('‚úÖ useContent: Wiki addition atualizada com sucesso:', { 
        additionId: data.additionId, 
        result: result,
        timestamp: new Date().toISOString()
      });
      
      // Recarregar conte√∫dos para refletir as mudan√ßas
      await loadContents();

      performanceLog('Atualiza√ß√£o de Wiki Addition', startTime);
      showNotification(`Adi√ß√£o "${data.title}" atualizada com sucesso!`, 'success');
      return true;
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao atualizar adi√ß√£o';
      safeError('‚ùå useContent: Erro ao atualizar Wiki Addition:', {
        error: err.message || err,
        data: {
          additionId: data.additionId,
          contentId: data.contentId,
          title: data.title
        },
        stack: err.stack,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      return false;
    }
  }, [loadContents, showNotification]);

  const uploadFile = useCallback(async (file: File) => {
    const startTime = performance.now();
    
    try {
      safeLog('üì§ useContent: Iniciando upload de arquivo:', {
        fileName: file.name,
        fileSize: `${(file.size / 1024).toFixed(2)} KB`,
        fileType: file.type,
        timestamp: new Date().toISOString()
      });
      
      // ‚úÖ VALIDA√á√ïES COM LOGS
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (file.size > maxSize) {
        const errorMsg = `Arquivo muito grande: ${(file.size / 1024 / 1024).toFixed(2)}MB. M√°ximo: 10MB`;
        safeWarn('‚ö†Ô∏è useContent: Arquivo muito grande:', {
          fileName: file.name,
          fileSize: file.size,
          maxSize
        });
        throw new Error(errorMsg);
      }
      
      const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/webm'];
      if (!allowedTypes.includes(file.type)) {
        safeWarn('‚ö†Ô∏è useContent: Tipo de arquivo n√£o suportado:', {
          fileName: file.name,
          fileType: file.type,
          allowedTypes
        });
        throw new Error(`Tipo de arquivo n√£o suportado: ${file.type}. Use: ${allowedTypes.join(', ')}`);
      }
      
      const result = await contentService.uploadFile(file);
      
      safeLog('‚úÖ useContent: Upload realizado com sucesso:', {
        fileName: file.name,
        result: result[0] ? {
          id: result[0].id,
          name: result[0].name,
          url: result[0].url,
          size: result[0].size
        } : result,
        timestamp: new Date().toISOString()
      });
      
      performanceLog('Upload de arquivo', startTime);
      showNotification('Arquivo enviado com sucesso!');
      return result;
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro no upload';
      safeError('‚ùå useContent: Erro no upload:', {
        error: err.message || err,
        fileName: file.name,
        fileSize: file.size,
        stack: err.stack,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      throw err;
    }
  }, [showNotification]);

  const deleteFile = useCallback(async (fileId: string): Promise<boolean> => {
    try {
      safeLog('üóëÔ∏è useContent: Iniciando exclus√£o de arquivo:', {
        fileId,
        timestamp: new Date().toISOString()
      });
      
      if (!fileId) {
        throw new Error('ID do arquivo inv√°lido');
      }
      
      const result = await contentService.deleteFile(fileId);

      if (result.success) {
        safeLog('‚úÖ useContent: Arquivo exclu√≠do com sucesso:', {
          fileId,
          timestamp: new Date().toISOString()
        });
        showNotification('Arquivo exclu√≠do com sucesso!', 'success');
        return true;
      } else {
        throw new Error(result.message || 'Falha ao excluir arquivo');
      }
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao excluir arquivo';
      safeError('‚ùå useContent: Erro ao excluir arquivo:', {
        error: err.message || err,
        fileId,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      return false;
    }
  }, [showNotification]);

  const getContentById = useCallback((id: string | number): ContentItem | undefined => {
    const content = contents.find(content => content.id.toString() === id.toString());
    
    if (ENV_CONFIG.isDev) {
      safeDebug('üîç useContent: Busca por ID:', {
        searchId: id,
        found: !!content,
        foundTitle: content?.title,
        totalContents: contents.length
      });
    }
    
    return content;
  }, [contents]);

  const clearError = useCallback(() => {
    safeLog('üßπ useContent: Limpando erro');
    setError(null);
  }, []);

  useEffect(() => {
    if (autoLoad) {
      safeLog('üöÄ useContent: Auto load habilitado:', {
        sector,
        timestamp: new Date().toISOString()
      });
      loadContents();
    } else {
      safeLog('‚è∏Ô∏è useContent: Auto load desabilitado');
    }
  }, [autoLoad, loadContents]);

  useEffect(() => {
    if (ENV_CONFIG.isDev) { 
      safeDebug('üìä useContent: Estado atualizado:', {
        contentsCount: contents.length,
        loading,
        hasError: !!error,
        errorMessage: error,
        sector,
        timestamp: new Date().toISOString(),
        contentsWithAdditions: contents.filter(c => (c as any)?.strapiData?.all_wiki_additions?.length > 0).length
      });
    }
  }, [contents.length, loading, error, sector]);

  return {
    // Estado
    contents,
    loading,
    error,
    
    // A√ß√µes b√°sicas
    loadContents,
    refreshContents,
    
    // CRUD de conte√∫do
    createContent,
    updateContent,
    deleteContent,
    
    // Wiki Additions
    createWikiAddition,
    deleteWikiAddition,
    
    // Upload de arquivos
    uploadFile,
    deleteFile,
    
    // Utilit√°rios
    getContentById,
    clearError,
  };
};

export default useContent;



/// arquivo em teste 


import { useState, useCallback, useEffect } from 'react';
import { contentService } from '../services/content.service';
import { ContentType, type ContentItem, type CreateContentData, type UpdateContentData } from '../types/content.types';
import type { SectorType } from '../types/common.types';
import { 
  safeLog, 
  safeWarn, 
  safeError, 
  safeDebug, 
  safeTime, 
  safeTimeEnd, 
  performanceLog,
  ENV_CONFIG 
} from '../utils/envUtils';

interface UseContentOptions {
  sector?: SectorType;
  autoLoad?: boolean;
}

interface UseContentReturn {
  // Estado
  contents: ContentItem[];
  loading: boolean;
  error: string | null;
  
  // A√ß√µes b√°sicas
  loadContents: () => Promise<void>;
  refreshContents: () => Promise<void>;
  
  // CRUD de conte√∫do
  createContent: (data: CreateContentData) => Promise<ContentItem>;
  updateContent: (id: string, data: UpdateContentData) => Promise<ContentItem>;
  deleteContent: (id: string) => Promise<boolean>;
  
  // Wiki Additions
  createWikiAddition: (data: {
    contentId: string;
    title: string;
    textContent: string;
    type: ContentType;
    file?: File;
    author?: string;
  }) => Promise<boolean>;
  deleteWikiAddition: (id: string | number) => Promise<boolean>;
  
  // Upload de arquivos
  uploadFile: (file: File) => Promise<any>;
  deleteFile: (fileId: string) => Promise<boolean>;
  
  // Utilit√°rios
  getContentById: (id: string | number) => ContentItem | undefined;
  clearError: () => void;
}

export const useContent = (options: UseContentOptions = {}): UseContentReturn => {
  const { sector, autoLoad = true } = options;
  
  // Estado
  const [contents, setContents] = useState<ContentItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const showNotification = useCallback((message: string, type: 'success' | 'error' = 'success') => {
    const notification = document.createElement('div');
    const bgColor = type === 'success' ? 'bg-green-500' : 'bg-red-500';
    notification.className = `fixed top-4 right-4 ${bgColor} text-white px-4 py-2 rounded shadow-lg z-50 max-w-sm`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
      if (document.body.contains(notification)) {
        document.body.removeChild(notification);
      }
    }, type === 'error' ? 5000 : 3000);
  }, []);

  const loadContents = useCallback(async () => {
    const startTime = performance.now();
    safeTime('useContent-loadContents');
    
    setLoading(true);
    setError(null);
    
    try {
      safeLog('üîÑ useContent: Carregando conte√∫dos...', { 
        sector, 
        timestamp: new Date().toISOString(),
        autoLoad 
      });
      
      const data = sector ? 
        await contentService.getContentsBySector(sector) : 
        await contentService.getAllContents();
      
      safeLog('‚úÖ useContent: Conte√∫dos carregados com sucesso:', {
        count: data.length,
        sector,
        timestamp: new Date().toISOString(),
        firstItem: data[0]?.title || 'Nenhum item',
        hasWikiAdditions: data.some(item => (item as any)?.strapiData?.all_wiki_additions?.length > 0)
      });
      
      setContents(data);
      performanceLog('Carregamento de conte√∫dos', startTime);
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao carregar conte√∫dos';
      safeError('‚ùå useContent: Erro ao carregar conte√∫dos:', {
        error: err.message || err,
        stack: err.stack,
        sector,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
    } finally {
      setLoading(false);
      safeTimeEnd('useContent-loadContents');
    }
  }, [sector, showNotification, autoLoad]);

  const refreshContents = useCallback(() => {
    safeLog('üîÑ useContent: Refresh manual solicitado');
    return loadContents();
  }, [loadContents]);

  const createContent = useCallback(async (data: CreateContentData): Promise<ContentItem> => {
    const startTime = performance.now();
    
    try {
      safeLog('‚ûï useContent: Criando conte√∫do:', {
        title: data.title,
        type: data.type,
        sector: data.sector,
        hasFile: !!(data as any).file,
        timestamp: new Date().toISOString()
      });
      
      const newContent = await contentService.createContent(data);
      
      setContents(prev => {
        const updated = [newContent, ...prev];
        safeDebug('üìä useContent: Estado atualizado ap√≥s cria√ß√£o:', {
          totalItens: updated.length,
          novoItem: {
            id: newContent.id,
            title: newContent.title
          }
        });
        return updated;
      });
      
      safeLog('‚úÖ useContent: Conte√∫do criado com sucesso:', {
        id: newContent.id,
        title: newContent.title,
        timestamp: new Date().toISOString()
      });
      
      performanceLog('Cria√ß√£o de conte√∫do', startTime);
      showNotification('Conte√∫do criado com sucesso!');
      return newContent;
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao criar conte√∫do';
      safeError('‚ùå useContent: Erro ao criar conte√∫do:', {
        error: err.message || err,
        data: { title: data.title, type: data.type },
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      throw err;
    }
  }, [showNotification]);

  const updateContent = useCallback(async (id: string, data: UpdateContentData): Promise<ContentItem> => {
    const startTime = performance.now();
    
    try {
      safeLog('üîÑ useContent: Atualizando conte√∫do:', {
        id,
        updates: Object.keys(data),
        timestamp: new Date().toISOString()
      });
      
      const updatedContent = await contentService.updateContent(id, data);
      
      setContents(prev => {
        const updated = prev.map(content => {
          const match = content.id.toString() === id.toString();
          if (match) {
            safeDebug('üîÑ useContent: Item atualizado no estado:', {
              id: content.id,
              oldTitle: content.title,
              newTitle: updatedContent.title
            });
          }
          return match ? updatedContent : content;
        });
        
        safeDebug('üìä useContent: Estado ap√≥s atualiza√ß√£o:', {
          totalItens: updated.length,
          itemAtualizado: updatedContent.title
        });
        
        return updated;
      });
      
      safeLog('‚úÖ useContent: Conte√∫do atualizado com sucesso:', {
        id,
        title: updatedContent.title,
        timestamp: new Date().toISOString()
      });
      
      performanceLog('Atualiza√ß√£o de conte√∫do', startTime);
      showNotification('Conte√∫do atualizado com sucesso!');
      return updatedContent;
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao atualizar conte√∫do';
      safeError('‚ùå useContent: Erro ao atualizar conte√∫do:', {
        error: err.message || err,
        id,
        updates: Object.keys(data),
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      throw err;
    }
  }, [showNotification]);

  const deleteContent = useCallback(async (id: string): Promise<boolean> => {
    const startTime = performance.now();
    
    try {
      safeLog('üóëÔ∏è useContent: Iniciando exclus√£o de conte√∫do:', {
        id,
        timestamp: new Date().toISOString()
      });
      
      const result = await contentService.deleteContent(id);
      
      if (result.success) {
        safeLog('‚úÖ useContent: Exclus√£o confirmada pela API');
        
        // ‚úÖ AGUARDAR UM POUCO PARA GARANTIR PERSIST√äNCIA
        safeDebug('‚è≥ useContent: Aguardando persist√™ncia no servidor...');
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // ‚úÖ FAZER RELOAD COMPLETO PARA GARANTIR SINCRONIZA√á√ÉO
        safeLog('üîÑ useContent: Recarregando lista completa ap√≥s exclus√£o...');
        await loadContents();
        
        performanceLog('Exclus√£o de conte√∫do (com reload)', startTime);
        showNotification('Conte√∫do exclu√≠do com sucesso!');
        return true;
        
      } else {
        throw new Error(result.message || 'Falha ao excluir conte√∫do');
      }
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao excluir conte√∫do';
      safeError('‚ùå useContent: Erro na exclus√£o:', {
        error: err.message || err,
        id,
        stack: err.stack,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      return false;
    }
  }, [contents, loadContents, showNotification]);

  const createWikiAddition = useCallback(async (data: {
    contentId: string;
    title: string;
    textContent: string;
    type: ContentType;
    file?: File;
    author?: string;
  }): Promise<boolean> => {
    const startTime = performance.now();
    
    try {
      safeLog('‚ûï useContent: Iniciando cria√ß√£o de Wiki Addition:', {
        contentId: data.contentId,
        title: data.title,
        type: data.type,
        hasFile: !!data.file,
        author: data.author || 'Sistema',
        timestamp: new Date().toISOString()
      });
      
      const content = contents.find(c => c.id.toString() === data.contentId);
      if (!content) {
        throw new Error(`Content com ID ${data.contentId} n√£o encontrado no estado local`);
      }
      
      const documentId = (content as any)?.strapiData?.documentId;
      if (!documentId) {
        throw new Error(`DocumentId n√£o encontrado para o content ID ${data.contentId}`);
      }
      
      safeLog('üìä useContent: Content parent localizado:', {
        contentId: data.contentId,
        documentId: documentId,
        contentTitle: content?.title,
        existingAdditions: (content as any)?.strapiData?.all_wiki_additions?.length || 0,
        timestamp: new Date().toISOString()
      });
      
      // ‚úÖ USAR CONTENTSERVICE COM DOCUMENT ID
      const result = await contentService.createWikiAddition({
        contentId: documentId, // ‚úÖ PASSAR DOCUMENT ID
        title: data.title,
        textContent: data.textContent,
        type: data.type,
        file: data.file,
        author: data.author
      });

      if (result.success) {
        safeLog('‚úÖ useContent: Wiki addition criada com sucesso:', {
          resultData: result.data,
          timestamp: new Date().toISOString()
        });
        
        // ‚úÖ AGUARDAR UM POUCO E RECARREGAR PARA PEGAR A NOVA ADI√á√ÉO
        safeDebug('‚è≥ useContent: Aguardando antes do reload...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        safeLog('üîÑ useContent: Recarregando conte√∫dos para incluir nova adi√ß√£o...');
        await loadContents();
        
        performanceLog('Cria√ß√£o de Wiki Addition (com reload)', startTime);
        showNotification(`Nova adi√ß√£o "${data.title}" criada com sucesso!`, 'success');
        return true;
        
      } else {
        throw new Error(result.message || 'Falha ao criar Wiki Addition');
      }
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao criar adi√ß√£o';
      safeError('‚ùå useContent: Erro ao criar Wiki Addition:', {
        error: err.message || err,
        data: {
          contentId: data.contentId,
          title: data.title,
          type: data.type
        },
        stack: err.stack,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      return false;
    }
  }, [contents, loadContents, showNotification]);

  const deleteWikiAddition = useCallback(async (id: string | number): Promise<boolean> => {
    const startTime = performance.now();
    
    try {
      safeLog('üóëÔ∏è useContent: Iniciando exclus√£o de Wiki Addition:', {
        id,
        idType: typeof id,
        timestamp: new Date().toISOString()
      });
      
      if (!id) {
        throw new Error('ID da adi√ß√£o n√£o fornecido');
      }

      // Converte para string para garantir compara√ß√£o consistente
      const idStr = String(id);
      safeLog('‚ÑπÔ∏è useContent: ID convertido para string para compara√ß√£o:', { idStr });

      // ‚úÖ CORRE√á√ÉO: Remove o item localmente para feedback instant√¢neo.
      setContents(prevContents => {
        const newContents = prevContents.map(item => {
          const strapiData = item.strapiData || {};
          const allWikiAdditions = strapiData.all_wiki_additions || [];
          
          // Filtra as adi√ß√µes que n√£o correspondem ao ID a ser exclu√≠do
          const updatedAdditions = allWikiAdditions.filter((add: any) => {
            const addIdStr = String(add.id);
            const matches = addIdStr !== idStr;
            if (!matches) {
              safeLog('‚ÑπÔ∏è useContent: Encontrada adi√ß√£o para remover localmente:', { 
                contentId: item.id, 
                additionId: add.id,
                additionTitle: add.title
              });
            }
            return matches;
          });
          
          // Se o n√∫mero de adi√ß√µes mudou, registra a remo√ß√£o
          if (updatedAdditions.length !== allWikiAdditions.length) {
            safeLog('üìä useContent: Wiki addition removida localmente do estado.', { 
              contentId: item.id, 
              additionId: id,
              removedCount: allWikiAdditions.length - updatedAdditions.length
            });
          }
          
          return {
            ...item,
            strapiData: {
              ...strapiData,
              all_wiki_additions: updatedAdditions
            }
          };
        });
        
        return newContents;
      });
      
      const result = await contentService.deleteWikiAddition(id);

      if (result.success) {
        safeLog('‚úÖ useContent: Wiki Addition exclu√≠da com sucesso via API');
        
        // ‚úÖ AGUARDAR E RECARREGAR
        safeDebug('‚è≥ useContent: Aguardando persist√™ncia...');
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        safeLog('üîÑ useContent: Recarregando para atualizar wiki additions...');
        await loadContents();
        
        performanceLog('Exclus√£o de Wiki Addition (com reload)', startTime);
        showNotification('Adi√ß√£o exclu√≠da com sucesso!', 'success');
        return true;
        
      } else {
        throw new Error(result.message || 'Falha ao excluir adi√ß√£o');
      }
      
    } catch (err: any) {
      const errorMessage = err.message || 'Erro ao excluir adi√ß√£o';
      safeError('‚ùå useContent: Erro ao excluir Wiki Addition:', {
        error: err.message || err,
        id,
        idType: typeof id,
        stack: err.stack,
        timestamp: new Date().toISOString()
      });
      setError(errorMessage);
      showNotification(errorMessage, 'error');
      return false;
    }
  }, [contents, loadContents, showNotification]);

  // ‚úÖ NOVO: ATUALIZAR WIKI ADDITION COM LOGS DETALHADOS
  const updateWikiAddition = useCallback(async (data: {
    additionId: string | number;
    contentId: string; // ID do artigo principal
    title: string;
    textContent: string;
    type: ContentType;
    file?: File;
    author?: string;
  }): Promise<boolean> => {
    const startTime = performance.now();
    
    try {
      safeLog('üîÑ useContent: Iniciando